#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <vector>
#include <set>
#include <unordered_map>
#include "gsl_utils.h"
#include "triplet_lib.hpp"

using namespace std;

vector<char*>* split(char* s1,char c)
{
  char* s=strdup(s1);
  vector<char*>* words=new vector<char*>();
  char* p=s;
  int done=0;
  while (1==1)
  {
    char* q=p;
    while (*q!='\n' && *q!='\0' && *q!=c) q++;
    if (*q=='\n' || *q=='\0') done = 1;
    *q = '\0';
    words->push_back(strdup(p));
    p = q+1;
    if (done==1) break;
  }
  free(s);
  return words;
}

//----------------------------------------------------------------------

void diff(double *a,double* b,double* c)
{
  for (int i=0 ; i<3 ; i++) c[i] = a[i]-b[i];
}

double dot(double *a,double* b)
{
  double s=0;
  for (int i=0 ; i<3 ; i++) s += a[i]*b[i]; 
  return s;
}

//  a<---b--->c
//    u    v

double angle(double* a,double* b,double* c)
{
  double u[3],v[3];
  diff(a,b,u); // u = a-b
  diff(c,b,v); // v = c-b
  double u2=dot(u,u); 
  double v2=dot(v,v);
  double uv=dot(u,v); // uv = u.v
  return (180/3.1415927)*acos(uv/sqrt(u2*v2));
}

// place b and d at origin, measure angle between vectors to a and c

double angle4(double* a,double* b,double* c,double *d)
{
  double u[3],v[3],z[3]={0,0,0};
  diff(a,b,u); // u = a-b
  diff(c,d,v); // v = c-d
  return angle(u,z,v);
}

void print_mat(double *mat,int N)
{
  int i,j;
  for (i=0 ; i<3 ; i++)
  {
    for (j=0 ; j<3 ; j++) printf("%6.3f ",(float)mat[i*N+j]);
    printf("\n");
  }
}

void print_vec(double *vec,int N)
{
  int i;
  for (i=0 ; i<3 ; i++) printf("%6.3f ",vec[i]);
  printf("\n");
}

//----------------------------------------------------------

Atom::Atom(float x,float y,float z) { co[0] = x; co[1] = y; co[2] = z; }

Atom::Atom(char* buf)
{
    char temp[10];
    copy_str(buf+6,temp,5);
    sscanf(temp,"%d",&anum);
    copy_str(buf+12,anam,4);
    alt = buf[16];
    copy_str(buf+17,rnam,3);
    chn = buf[21];
    copy_str(buf+22,temp,4);
    sscanf(temp,"%d",&rnum);

    copy_str(buf+30,temp,8);
    sscanf(temp,"%lf",&co[0]);
    copy_str(buf+38,temp,8);
    sscanf(temp,"%lf",&co[1]);
    copy_str(buf+46,temp,8);
    sscanf(temp,"%lf",&co[2]);
    copy_str(buf+54,temp,6);
    sscanf(temp,"%lf",&occ);
    copy_str(buf+60,temp,6);
    sscanf(temp,"%lf",&bfact);
}

// copy exactly n chars, then add NULL

void Atom::copy_str(char* src,char* dest,int n)
{
  int i; for (i=0 ; i<n ; i++) dest[i] = src[i]; dest[n] = '\0';
}

char* Atom::id()
{
  char temp[100];
  sprintf(temp,"%s%d%c.%s",rnam,rnum,chn,anam+1);
  return strdup(temp);
}

void Atom::print()
{
  printf("ATOM  %5d %s%c%s %c%4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n",anum,anam,alt,rnam,chn,rnum,co[0],co[1],co[2],occ,bfact);
}

vector<Atom*>* read_pdb(char* fname)
{
  vector<Atom*>* atoms=new vector<Atom*>();
  int i=0;
  FILE* fil=fopen(fname,"r");
  char buf[1000];
  while (fgets(buf,1000,fil))
  {
    if (strlen(buf)<6 || strncmp(buf,"ATOM  ",6)!=0) continue;
    atoms->push_back(new Atom(buf));
  }
  fclose(fil);
  return atoms;
}

// special case for reading ligand files generated by QMD
// separated by END records
// return list of chains

vector<vector<Atom*>*>* read_conformers(char* fname)
{
  vector<vector<Atom*>*>* chains=new vector<vector<Atom*>*>();
  int i=0;
  FILE* fil=fopen(fname,"r");
  char buf[1000];
  vector<Atom*>* atoms=new vector<Atom*>();
  while (fgets(buf,1000,fil))
  {
    if (strncmp(buf,"ENDMDL",6)==0)
    {
      chains->push_back(atoms);
      atoms = new vector<Atom*>();
    }  
    if (strlen(buf)<6 || strncmp(buf,"ATOM  ",6)!=0) continue;
    atoms->push_back(new Atom(buf));
  }
  fclose(fil);
  return chains;
}

vector<char*>* read_frames(char* fname)
{
  vector<char*>* remarks=new vector<char*>();
  FILE* fil=fopen(fname,"r");
  char buf[1000];
  while (fgets(buf,1000,fil))
    if (strstr(buf,"origframe")!=NULL)
      remarks->push_back(strdup(buf));
  return remarks;
}

void print_pdb(int anum,char* anam,int rnum,char* rnam,char chn,double* co,float occ,float bfact)
{
  printf("ATOM  %5d %s %s %c%4d    %8.3f%8.3f%8.3f%6.2f%6.2f\n",anum,anam,rnam,chn,rnum,co[0],co[1],co[2],occ,bfact);
}

int nucleic(Atom* a)
{
  if (strcmp(a->rnam,"  A")==0) return 1;
  if (strcmp(a->rnam,"  G")==0) return 1;
  if (strcmp(a->rnam,"  C")==0) return 1;
  if (strcmp(a->rnam,"  T")==0) return 1;
  if (strcmp(a->rnam,"  U")==0) return 1;
  if (strcmp(a->rnam," DA")==0) return 1;
  if (strcmp(a->rnam," DG")==0) return 1;
  if (strcmp(a->rnam," DC")==0) return 1;
  if (strcmp(a->rnam," DT")==0) return 1;
  return 0;
}

//---------------------------------

void Match::transform(double* A,double* B)
{
  double C[3],D[3];
  for (int i=0 ; i<3 ; i++) C[i] = A[i]-cen1[i];
  mul_mat_vec(rot,C,D,3);
  for (int i=0 ; i<3 ; i++) B[i] = D[i]+cen2[i];
}

bool match_compare(const Match* a,const Match* b) { return a->rms<b->rms; }

typedef double COORDS[3];

double calc_angle_score(COORDS* co1,COORDS* co2)
{
  double angs=0.0;
  for (int i=0 ; i<3 ; i++) angs += angle4(co1[i*2],co1[i*2+1],co2[i*2],co2[i*2+1]);
  return angs/3.0;
}

// global variables
float Wang=1,Wdist=1;

Match* compare_3vecs(vector<Atom*>& a,vector<Atom*>& b)
{
  Match* match=new Match();
  double co1[6][3],co2[6][3];
  for (int i=0 ; i<6 ; i++)
    for (int j=0 ; j<3 ; j++) { co1[i][j] = a[i]->co[j]; co2[i][j] = b[i]->co[j]; }

  for (int i=0 ; i<3 ; i++) match->cen1[i] = match->cen2[i] = 0;
  for (int i=0 ; i<6 ; i++)
    for (int j=0 ; j<3 ; j++) { match->cen1[j] += co1[i][j]; match->cen2[j] += co2[i][j]; }
  for (int i=0 ; i<3 ; i++) { match->cen1[i] /= 6.0; match->cen2[i] /= 6.0; }
  for (int i=0 ; i<6 ; i++)
    for (int j=0 ; j<3 ; j++) { co1[i][j] -= match->cen1[j]; co2[i][j] -= match->cen2[j]; }

  // assume coords are pre-centered, rotation of first onto second
  match->rms = superpose_rms((double*)co1,(double*)co2,6,match->rot);

  double co3[6][3];
  for (int i=0 ; i<6 ; i++) match->transform(co1[i],co3[i]);
  match->angle = calc_angle_score(co2,co3);
  match->score = Wdist*match->rms + Wang*match->angle;
  return match;
}

//------------------------------------------------------------

int cnt,maxdepth;

KDTree::~KDTree()
{
  if (left!=NULL) delete left;
  if (right!=NULL) delete right;
}

KDTree::KDTree(vector<Atom*>* A)
{
    atoms = A;
    if (A->size()<=1) { left = right = NULL; return; }
    double maxs[3],mins[3];
    for (int i=0 ; i<A->size() ; i++)
      for (int j=0 ; j<3 ; j++)
      {
        if (i==0 || A->at(i)->co[j]<mins[j]) mins[j] = A->at(i)->co[j];
        if (i==0 || A->at(i)->co[j]>maxs[j]) maxs[j] = A->at(i)->co[j];
      }
    double best; // range
    for (int i=0 ; i<3 ; i++)
      if (i==0 || (maxs[i]-mins[i]>best)) { dim = i; best = maxs[i]-mins[i]; }

    // bisect method
    val = (maxs[dim]+mins[dim])/2.0; // midpt
    for (int i=0 ; i<A->size() ; i++)
      if (i==0 || fabs(val-A->at(i)->co[dim])<best) { cutpt = i; best = fabs(val-A->at(i)->co[dim]); }
    val = A->at(cutpt)->co[dim];

    for (int i=0 ; i<A->size() ; i++)
    {
      if (i==cutpt) continue;
      if (A->at(i)->co[dim]<=val) leftatoms.push_back(A->at(i));
      else rightatoms.push_back(A->at(i));
    }
    left = new KDTree(&leftatoms);
    right = new KDTree(&rightatoms);
}

// uses dsq member of Atom record for convenient storate of dist^2 to target

Atom* KDTree::nearest(Atom* target,int depth,double best_dsq_so_far)
{
    cnt++; 
    if (depth>maxdepth) maxdepth = depth;
    if (atoms->size()==0) return NULL;
    if (atoms->size()==1) { atoms->at(0)->dsq = dist2(target->co,atoms->at(0)->co); return atoms->at(0); }
    KDTree *goodside,*badside;
    if (target->co[dim]<=val) { goodside = left; badside = right; }
    else { goodside = right; badside = left; }
    Atom* closest=atoms->at(cutpt);
    closest->dsq = dist2(target->co,closest->co);
    Atom* temp=goodside->nearest(target,depth+1,best_dsq_so_far);
    if (temp!=NULL && temp->dsq<closest->dsq) closest = temp;
    best_dsq_so_far = min(best_dsq_so_far,closest->dsq);
    if ((target->co[dim]-val)*(target->co[dim]-val)<best_dsq_so_far)
    {
      Atom* other=badside->nearest(target,depth+1,best_dsq_so_far);
      if (other!=NULL && other->dsq<closest->dsq) closest = other;
    }
    return closest;
}

//----------------------------------------------------------------------

// global variables
float CONTACT=4,POINTING=90;

vector<int>* interface_residues(vector<Atom*>& chain1,vector<Atom*>& chain2) 
{
  vector<int>* resnums=new vector<int>();
  if (chain1.size()==0 || chain2.size()==0) return resnums;

  KDTree kd=KDTree(&chain2);
  set<int> resnumset; // keep unique rnums only
  unordered_map<int,vector<Atom*> > contacts; // keep track of contacts for each res
  for (int i=0 ; i<chain1.size() ; i++)
  {
    Atom* a=chain1[i];
    Atom* b=kd.nearest(a,0,999999); 
    if (dist2(a->co,b->co)<CONTACT*CONTACT)
    {
      resnumset.insert(a->rnum);
      contacts[a->rnum].push_back(b);
    }
  }

  // remove glycines; check that Ca-Ca is pointing toward other chain
  for (set<int>::iterator iter=resnumset.begin() ; iter!=resnumset.end() ; iter++)
  {
    int rnum=*iter;
    Atom* Ca=NULL,*Cb=NULL;
    for (vector<Atom*>::iterator atom=chain1.begin() ; atom!=chain1.end() ; atom++)
    {
      if ((*atom)->rnum==rnum && strcmp((*atom)->anam," CA ")==0) Ca = *atom;
      if ((*atom)->rnum==rnum && strcmp((*atom)->anam," CB ")==0) Cb = *atom;
    }
    if (Ca==NULL || Cb==NULL) continue; // ignores glycines and incomplete residues
    double best_angle=360;
    for (int i=0 ; i<contacts[rnum].size() ; i++)
    {
      double a=angle(Cb->co,Ca->co,contacts[rnum][i]->co);
      if (a<best_angle) best_angle = a;
    }
    if (best_angle<POINTING) resnums->push_back(rnum);
  }
  return resnums;
}

